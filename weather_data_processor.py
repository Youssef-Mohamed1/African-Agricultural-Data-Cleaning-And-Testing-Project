{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "6b3aac3e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# These are the imports we're going to use in the weather data processing module\n",
    "import re\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import logging\n",
    "import data_ingestion"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "f142baa5",
   "metadata": {},
   "outputs": [],
   "source": [
    "### START FUNCTION \n",
    "\n",
    "class WeatherDataProcessor:\n",
    "    \"\"\"Processes weather data based on configuration parameters.\n",
    "\n",
    "    Args:\n",
    "        config_params (dict): A dictionary containing configuration parameters.\n",
    "        logging_level (str, optional): The logging level. Defaults to \"INFO\".\n",
    "\n",
    "    Attributes:\n",
    "        weather_station_data (str): The path to the weather CSV file.\n",
    "        patterns (dict): A dictionary mapping measurement keys to regex patterns.\n",
    "        weather_df (DataFrame): The DataFrame containing weather data.\n",
    "        logger (logging.Logger): The logger object.\n",
    "\n",
    "    Methods:\n",
    "        initialize_logging(logging_level): Initializes logging for the instance.\n",
    "        weather_station_mapping(): Maps weather station data to the DataFrame.\n",
    "        extract_measurement(message): Extracts a measurement from a message using regex patterns.\n",
    "        process_messages(): Processes messages to extract measurements.\n",
    "        calculate_means(): Calculates the mean values of measurements.\n",
    "        process(): Executes the processing pipeline.\n",
    "\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, config_params, logging_level=\"INFO\"):\n",
    "        \"\"\"Initializes the WeatherDataProcessor instance.\n",
    "\n",
    "        Args:\n",
    "            config_params (dict): A dictionary containing configuration parameters.\n",
    "            logging_level (str, optional): The logging level. Defaults to \"INFO\".\n",
    "\n",
    "        \"\"\"\n",
    "        self.weather_station_data = config_params['weather_csv_path']\n",
    "        self.patterns = config_params['regex_patterns']\n",
    "        self.weather_df = None\n",
    "        self.initialize_logging(logging_level)\n",
    "\n",
    "    def initialize_logging(self, logging_level):\n",
    "        \"\"\"Sets up logging for the WeatherDataProcessor instance.\n",
    "\n",
    "        Args:\n",
    "            logging_level (str): The logging level.\n",
    "\n",
    "        \"\"\"\n",
    "        logger_name = __name__ + \".WeatherDataProcessor\"\n",
    "        self.logger = logging.getLogger(logger_name)\n",
    "        self.logger.propagate = False\n",
    "\n",
    "        if logging_level.upper() == \"DEBUG\":\n",
    "            log_level = logging.DEBUG\n",
    "        elif logging_level.upper() == \"INFO\":\n",
    "            log_level = logging.INFO\n",
    "        elif logging_level.upper() == \"NONE\":\n",
    "            self.logger.disabled = True\n",
    "            return\n",
    "        else:\n",
    "            log_level = logging.INFO\n",
    "\n",
    "        self.logger.setLevel(log_level)\n",
    "\n",
    "        if not self.logger.handlers:\n",
    "            ch = logging.StreamHandler()\n",
    "            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n",
    "            ch.setFormatter(formatter)\n",
    "            self.logger.addHandler(ch)\n",
    "\n",
    "    def weather_station_mapping(self):\n",
    "        \"\"\"Maps weather station data to the DataFrame.\"\"\"\n",
    "        self.weather_df = read_from_web_CSV(self.weather_station_data)\n",
    "        self.logger.info(\"Successfully loaded weather station data from the web.\")\n",
    "\n",
    "    def extract_measurement(self, message):\n",
    "        \"\"\"Extracts a measurement from a message using regex patterns.\"\"\"\n",
    "        for key, pattern in self.patterns.items():\n",
    "            match = re.search(pattern, message)\n",
    "            if match:\n",
    "                self.logger.debug(f\"Measurement extracted: {key}\")\n",
    "                return key, float(next((x for x in match.groups() if x is not None)))\n",
    "        self.logger.debug(\"No measurement match found.\")\n",
    "        return None, None\n",
    "\n",
    "    def process_messages(self):\n",
    "        \"\"\"Processes messages to extract measurements.\"\"\"\n",
    "        if self.weather_df is not None:\n",
    "            result = self.weather_df['Message'].apply(self.extract_measurement)\n",
    "            self.weather_df['Measurement'], self.weather_df['Value'] = zip(*result)\n",
    "            self.logger.info(\"Messages processed and measurements extracted.\")\n",
    "        else:\n",
    "            self.logger.warning(\"weather_df is not initialized, skipping message processing.\")\n",
    "        return self.weather_df\n",
    "\n",
    "    def calculate_means(self):\n",
    "        \"\"\"Calculates the mean values of measurements.\"\"\"\n",
    "        if self.weather_df is not None:\n",
    "            means = self.weather_df.groupby(by=['Weather_station_ID', 'Measurement'])['Value'].mean()\n",
    "            self.logger.info(\"Mean values calculated.\")\n",
    "            return means.unstack()\n",
    "        else:\n",
    "            self.logger.warning(\"weather_df is not initialized, cannot calculate means.\")\n",
    "            return None\n",
    "\n",
    "    def process(self):\n",
    "        \"\"\"Executes the processing pipeline.\"\"\"\n",
    "        self.weather_station_mapping()\n",
    "        self.process_messages()\n",
    "        self.logger.info(\"Data processing completed.\")\n",
    "        \n",
    "### END FUNCTION"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
